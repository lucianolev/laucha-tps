\documentclass[a4paper,11pt] {article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{caratula}
\usepackage{a4wide}
%\usepackage{graphicx}
% \usepackage{dot2texi}
% \usepackage{graphs}

\begin{document}

\titulo{Trabajo Pr\'actico Nro. 1}
\fecha{21/04/2010}
\materia{Ingenier\'ia de Software I}
\grupo{}
\integrante{Dinota, Mat\'ias}{076/07}{matiasgd@gmail.com}
\integrante{Frid, Igal Pablo}{231/07}{ipfrid@gmail.com}
\integrante{Huel, Federico Ariel}{329/07}{federico.huel@gmail.com}
\integrante{Leveroni, Luciano}{360/07}{lucianolev@gmail.com}
\integrante{Mosteiro, Agust\'in}{125/07}{agustinmosteiro@gmail.com}

\maketitle

\bigskip
\section*{Aclaraciones generales}

%Antes de comenzar el an\'alisis de los algoritmos, cabe mencionar lo siguiente:
%
%\begin{itemize}
% \item La implementaci\'on de los todos algoritmos se realiz\'o en \textbf{lenguaje Java}, haciendo uso de las librer\'ias est\'andar del mismo.
% \item Para el c\'alculo de tiempo de los algoritmos se utiliz\'o la funci\'on \textbf{nanoTime()} de la clase System de Java. Con el fin de aumentar la precisi\'on de las mediciones, se utiliz\'o el comando \textbf{nice} para darle m\'axima prioridad a la tarea.
% \item El c\'odigo fuente de los algoritmos aqu\'i analizados se encuentran en el archivo \textit{ResolvedorCIPM.java}.
% \item El c\'odigo fuente de los programas encargados de hacer uso de los algoritmos y necesarios para compilar la aplicaciones son: MainCIPM.java, ResolvedorCIPM.java, GrafoNPonderados.java, PesoNodoComparator.java, LectorDeGrafos.java y EscritorDeSoluciones.java.
% \item Para la lectura y escritura de los datos se utilizaron clases provistas por el lenguaje Java. No se har\'a referencia a estos algoritmos ya que no resultan de inter\'es para el trabajo aqu\'i presentado.
% \item Los gr\'aficos se realizaron con \textbf{GNUPlot} y las tablas con OpenOffice Calc. En los casos considerados pertinentes, se utiliz\'o una escala logar\'itmica con el fin de poder visualizar mejor los resultados.
%\end{itemize}
%
%Con respecto al an치lisis de resultados y a las pruebas realizadas vale hacer la siguiente aclaraci칩n. Los grafos generados aletoriamente poseer치n nodos con pesos comprendidos entre $10$ y cantidad de nodos del grafo por $10$. Las adyacencias de los nodos es generada tambi칠n aleatoriamente de modo que el grado de cada nodo sea un n칰mero entre 0 y (n-1)*k, con $k$ un par치metro que llamaremos \textit{densidad} de aqu칤 en adelante, donde $0 < k \leq 1$. De este modo, los experimentos mostrar치n el comportamiento de los algoritmos para grafos ``promedio'' (sin particularidades) con una cierta cantidad de nodos y de cierta densidad.

\section*{Introducci\'on}

El objetivo del siguiente trabajo es modelar un sistema para una cadena de pizzer\'ias, denominada Pizza Hack. Con este fin, se utilizar\'an t\'ecnicas de ingenier\'ia de requerimientos, a saber: Diagrama de Contexto y de Objetivos. A su vez, se incluyen en el presente trabajo las explicaciones y detalles de cada uno de los diagramas para clarificar lo expuesto de forma gr\'afica en dichos diagramas. 

El sistema a modelar pretende resolver las necesidades y problemas de una cadena de pizzer\'ias t\'ipica, en la que cada uno de los locales atiende al p\'ublico a trav\'es de un mostrador, es decir, no ofrece la posibilidad de consumir las pizzas en el mismo local. Adem\'as, cabe aclarar que la cadena de pizzer\'ias desea mantener el mismo men\'u en todos sus locales, por lo que un cambio en el men\'u de un local deber\'a verse reflejado en la cartilla de los restantes. Tambi\'en se debe mencionar que los locales no ofrecen servicio de delivery y, en caso de que alg\'un pedido no se pueda preparar en el local donde se encuentra el cliente, se ofrecer\'a derivar su pedido a otro local de la cadena. Por \'ultimo, hay que tener en cuenta que el sistema no debe tener un servidor centralizado para la coordinaci\'on entre locales.

Por medio de la aplicaci\'on de las t\'ecnicas de inginier\'ia de requerimientos se busca explorar distintas opciones para modelar el sistema deseado por la cadena de pizzas. Finalmente, se estudiar\'an las ventajas y desventajas que conlleva elegir cada una de estas alternativas en los aspectos que consideramos relevantes para el funcionamiento del sistema y el beneficio de la cadena de pizzas.  

\section*{Presunciones}

\section*{Vistas}

\section*{Escenarios}
A continuaci\'on se mostrar\'an algunos de los posibles escenarios que se podr\'ian llegar a presentarse en la cadena de pizzas describida. 
\begin{itemize}
	\item Un cliente realiza un pedido en un local y el mismo puede ser preparado. Una vez listo el pedido, se le entrega al cliente y este se retira satisfecho.
	\item Un cliente realiza un pedido en un local y el mismo no puede ser preparado. Se le ofrece al cliente la opci\'on de derivar su pedido al local m\'as cercano 
\end{itemize}

\section*{Discusi蚤}

\section*{Conclusiones Generales}

%El trabajo aqui realizado se encarg칩 de mostrar diversos algoritmos para resolver el problema del conjunto independiente de peso m치ximo para un grafo de nodos ponderados cualquiera. En primer lugar se realiz칩 un simple algoritmo exacto de orden $O(2^n)$ para posteriores comparaciones con las heuristicas propuestas. Este orden exponencial, mostr칩 luego que el algoritmo s칩lo termina en un tiempo razonable para grafos relativamente peque침os (hasta 36 nodos, con baja densidad). 
%
%Luego, se comenz칩 por mostrar distintas heur칤sticas constructivas para generar soluciones al problema para grafos m치s grandes. Como vimos, si bien se mostraron heur칤sticas mejores que otras, todas ellas resultaron estar relativamente lejos de la soluci칩n exacta. Por pruebas realizadas, se concluy칩 que la mejor heur칤stica result칩 ser una heur칤stica golosa que a침ade los nodos con mayor relaci칩n peso/grado del grafo a la solucion parcial. De este modo, el algorimto encontrar칤a soluciones en un tiempo polinomial $O(n*m)$ permitiendo ser ejecutado sobre grafos de un orden de $10^3$ de baja densidad en tiempos razonables.
%
%En la siguiente etapa se estudiaron 2 heur칤sticas de b칰squeda local con el fin de mejorar las soluciones contructivas obtenidas. Result칩 interesante ver como una busqueda local bastante m치s inteligente di칩 resultados notablemente mejores, a칰n siendo de una complejidad temporal aceptable como ser $O(n*m)$. M치s a칰n, realizar la heur칤stica sola o utilizar una busqueda local a posteriori conserva la complejidad de $O(n*m)$ por lo cual se puede concluir que la heur칤stica por s칤 sola carece de utilidad. Otro punto interesante, es que la b칰squeda realiza una cantidad de iteraci칩nes que aumenta muy levemente con respecto al tama침o del grafo, por lo cual fue posible acotar dicho par치metro sin perder en calidad de soluciones encontradas.
%
%Por 칰ltimo se estudi칩 una versi칩n del esquema metaheur칤stico GRASP que muestra como la mejora en la calidad de las soluciones es a칰n mayor que realizar una b칰squeda local. Tal como explica la bibliograf칤a asociada, este resultado tiene relaci칩n con el hecho de que se realizan distintas busquedas locales en diversas soluciones iniciales lo que resulta en el aumentar notablemente la posibilidad de hallar soluciones mejores. Adem치s, al haber fijado la cantidad de iteraciones del procedimiento, la complejidad te칩rica sigue siendo del mismo 칩rden que realizar una 칰nica busqueda local, es decir $O(n*m)$. Esto 칰ltimo muestra como este esquema metaheur칤stico resulta de gran utilidad al momento de querer encontrar soluciones de calidad para problemas de gran tama침o imposibles de resolver de forma exacta.

\section*{Referencias}
%\begin{itemize}
% \item ``Greedy Randomized Adaptive Search Procedures'' - Thomas A. Feo, Mauricio G.C. Resende
% \item Art\'iculo de Wikipedia sobre Conjunto independiente
%\end{itemize}

\end{document}